# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/info.ipynb (unless otherwise specified).

__all__ = ['KEYS_TO_DISCARD', 'insp2acao', 'issue_type', 'utf2ascii', 'detalhar_issue', 'download_attachments',
           'extract_attachment', 'extract_attachments']

# Cell
import re
import json
from unidecode import unidecode
from datetime import datetime, timedelta
import contextlib
from typing import Union, Iterable

from rich import print
from tqdm.auto import tqdm
from redminelib import Redmine
from redminelib.resources import Issue
from redminelib.exceptions import ResourceAttrError, ReadonlyAttrError

from fastcore.foundation import L
from fastcore.xtras import is_listy, listify, Path
from fastcore.script import Param, call_parse, bool_arg
from fastcore.parallel import parallel
from fastcore.basics import partialler


from .constants import ACAO_DESCRIPTION, KWARGS, IDS, FIELDS, JSON_FIELDS
from .validation import valida_fiscaliza, issue2users
from .format import view_string
KEYS_TO_DISCARD = ['Users', 'Anexos']

# Cell
def insp2acao(issue: Union[str, Issue], fiscaliza: Redmine) -> dict:
    """Recebe o objeto `fiscaliza` e a string referente à inspeção `insp` e retorna um dicionário resumo da Ação atrelada à inspeção

    Args:
        redmineObj (Redmine): Objeto Redmine autenticado
        insp (str): string com o número da inspeção

    Returns:
        dict: Dicionário com o id, nome e descrição da Ação associada à inspeção

    """
    fiscaliza = valida_fiscaliza(fiscaliza=fiscaliza)
    if not isinstance(issue, Issue) and isinstance(issue, (str, int)):
        issue = fiscaliza.issue.get(issue, include=["relations", "attachments"])

    if "INSP" not in str(issue.subject):
        return {}
    if relations := getattr(issue, "relations", []):
        if relations := getattr(relations, "values", []):
            relations = relations()
    for relation in relations:
        if issue_to_id := relation.get("issue_to_id", None):
            if issue_to_id := fiscaliza.issue.get(issue_to_id):
                if "ACAO" in str(issue_to_id) or (
                    (tracker := getattr(issue_to_id, "tracker", None))
                    and (getattr(tracker, "id", None) == 2)
                ):
                    if (
                        description := getattr(issue_to_id, "custom_fields", None)
                    ) is None:
                        description = ""

                    elif description := description.get(ACAO_DESCRIPTION, None):
                        description = getattr(description, "value", "")
                    else:
                        description = ""
                    return {
                        "id_ACAO": getattr(issue_to_id, "id", ""),
                        "nome_ACAO": str(issue_to_id),
                        "descricao_ACAO": description,
                    }
    return {"id_ACAO": "", "nome_ACAO": "", "descricao_ACAO": ""}

# Cell
def issue_type(insp, fiscaliza):
    """Checa se a Issue de nº `insp` do Redmine é de um dos tipos válidos: `Inspeção | Ação`"""
    if (tipo := fiscaliza.issue.get(insp).tracker["id"]) == 1:
        return "Inspeção"
    elif tipo == 2:
        return "Ação"
    return "Desconhecido"

# Cell
def utf2ascii(s):
    """Recebe uma string e retorna a mesma em formato ASCII"""
    s = re.sub("[!\"#$%&'()*+\,\-\.\/:;<=>\?@[\\]\^`_\{\|\}~]", "", s)
    return unidecode(s.replace(" ", "_"))


def detalhar_issue(
    issue: str,
    login: str = None,
    senha: str = None,
    api: str = None,
    fiscaliza: Redmine = None,
    teste: bool = True,
) -> dict:  # sourcery skip: remove-unnecessary-cast
    """Recebe número da inspeção `inspecao`, o login e senha ou opcionalmente objeto Redmine logado `fiscaliza`
    inspecao: str - Número da Inspeção a ser relatada
    login: str - Login Anatel do Usuário
    senha: str - Senha Utilizada nos Sistemas Interativos da
    fiscaliza: Redmine - Objeto Redmine logado, opcional ao login e senha
    teste: bool - Caso verdadeiro o Fiscaliza de Teste ( Homologação ) é utilizado

    Returns:
        dict: Retorna um dicionário com a Situação Atual e campos preenchidos da Inspeção

    """

    if not isinstance(issue, Issue) and isinstance(issue, (str, int)):
        fiscaliza = valida_fiscaliza(login, senha, api, fiscaliza, teste)
        issue = fiscaliza.issue.get(issue, include=["relations", "attachments"])

    issue_data = {}

    if (attachments := getattr(issue, "attachments")) is not None:
        issue_data["Anexos"] = {d["filename"]: d["content_url"] for d in attachments}

    issue_data.update({k: str(getattr(issue, k, "")) for k in KWARGS})

    id2field = dict(zip(IDS, FIELDS))

    if custom_fields := listify(getattr(issue, "custom_fields", None)):
        for field in custom_fields:
            try:
                issue_data[id2field.get(field.id, utf2ascii(field.name))] = getattr(
                    field, "value", ""
                )
            except ResourceAttrError as e:
                raise ValueError(
                    f"O atributo 'value' não existe na Issue mencionada: key {field.id}, name: {field.name}"
                ) from e

    issue_data.update(insp2acao(issue, fiscaliza))
    id2users, users2id = issue2users(issue, fiscaliza)

    if (value := issue_data.get("Fiscal_Responsavel", None)) is not None:
        with contextlib.suppress(ValueError):
            issue_data["Fiscal_Responsavel"] = id2users.get(int(value), value)

    if (value := issue_data.get("Fiscais", None)) is not None:
        with contextlib.suppress(ValueError):
            issue_data["Fiscais"] = [
                id2users.get(int(v), v) for v in issue_data["Fiscais"]
            ]

    users = list(users2id.keys())
    issue_data["Users"] = users

    for f in JSON_FIELDS:
        if (field := issue_data.get(f)) is None:
            issue_data[f] = ""
            continue
        if is_listy(field):
            issue_data[f] = [view_string(s) for s in field]
        else:
            issue_data[f] = view_string(field)

    if journal := list(issue.journals):
        journal = dict(journal[-1])
        key = "user"
    else:
        journal = dict(issue)
        key = "author"

    user = journal[key]["name"]
    date = datetime.strptime(journal["created_on"], "%Y-%m-%dT%H:%M:%SZ") - timedelta(
        hours=3
    )

    issue_data[
        "Atualizado"
    ] = f"Atualizado por {user} em {datetime.strftime(date, '%d/%m/%Y')} às {date.time()}"

    if coords := issue_data.pop('Coordenadas_Geograficas', None):
        issue_data['Latitude'] = json.loads(coords.replace("=>", ": "))["latitude"]
        issue_data['Longitude'] = json.loads(coords.replace("=>", ": "))["longitude"]


    return issue_data


def _download_attachment(
    attach: Issue,
    savepath: Path,
) -> None:
    """Recebe número da inspeção `inspecao`, o login e senha ou opcionalmente objeto Redmine logado `fiscaliza`
    issue_obj: Issue - Objeto na qual o anexo está contido
    fiscaliza: Redmine - Objeto Redmine logado, opcional ao login e senha
    savepath: str - Caminho para salvar o anexo

    Returns:
        None: Somente salva os arquivos desejados.
    """

    url = getattr(attach, "content_url").replace("http://", "https://")
    setattr(attach, "content_url", url)
    filename = f"{attach.Inspecao['id']}_{attach.id}_{attach.filename}"
    attach.download(
        savepath=savepath,
        filename=filename,
    )
    d = dict(attach)
    d["author"] = d["author"]["name"]
    filename = Path(savepath / filename)
    js = filename.read_json()
    js.update(d)
    json.dump(js, filename.open("w"))


@call_parse  # Workaround the bug in recursion call in extract_attachments when using as a console script
def _download_attachments(
    issue_obj: Param("Número da Issue ou Objeto Issue do Redmine"),
    savepath: Param("Caminho para salvar os arquivos", str),
    login: Param("Login Anatel do Usuário", str) = None,
    senha: Param("Senha Utilizada nos Sistemas Interativos da Anatel", str) = None,
    api: Param("Chave API para autenticação. Alternativo ao login e senha", str) = None,
    teste: Param("Indica se o relato será de teste", bool_arg) = True,
):
    download_attachments(issue_obj, savepath, login, senha, api, teste)


def download_attachments(
    issue_obj: Union[str, int],
    savepath: Union[str, Path],
    login: str = None,
    senha: str = None,
    api: str = None,
    teste: bool = True,
):  # sourcery skip: remove-unnecessary-cast
    attachments = extract_attachments(issue_obj, login, senha, api, teste=teste)
    savepath = Path(f"{savepath}/{issue_obj}")
    savepath.mkdir(exist_ok=True, parents=True)
    func = partialler(_download_attachment, savepath=savepath)
    parallel(func, attachments, threadpool=True, n_workers=min(len(attachments), 16))


def extract_attachment(
    issue_obj,
    filename: Iterable[str] = "Info.json",
    only_last: bool = True,
    fiscaliza: Redmine = None,
):
    if attach := L(getattr(issue_obj, "attachments", [])):
        if filename:
            attach = attach.filter(lambda x: x.filename in listify(filename))
        if only_last:
            ids = attach.attrgot("id")
            last_id = ids.argwhere(lambda x: x == max(ids))
            attach = attach[last_id]
        if fiscaliza:
            inspecao = {}
            d = detalhar_issue(issue_obj, fiscaliza=fiscaliza)
            for k in KEYS_TO_DISCARD:
                d.pop(k, None)
            if relatorio := d.pop("Relatorio_de_Monitoramento", None):
                d['Relatorio_SEI'] = json.loads(relatorio.replace("=>", ": "))["numero"]
            if sei := d.pop('Numero_Sei_do_Processo', None):
                d['Processo_SEI'] = json.loads(sei.replace("=>", ": "))["numero"]
            for k in KEYS_TO_DISCARD:
                inspecao.pop(k, None)
            for k,v in d.items():
                if is_listy(v):
                    v = "|".join(v)
                if v: inspecao[k] = str(v)
            attach.setattrs('Inspecao', inspecao)
        else:
            attach.setattrs("Inspecao", issue_obj.id)

    return attach


def extract_attachments(
    issue_obj: Union[str, int, Issue],
    login: str = None,
    senha: str = None,
    api: str = None,
    fiscaliza: Redmine = None,
    teste: bool = True,
    subset: Iterable[str] = ("relatada", "conferida", "aprovada"),
    filename: str = "Info.json",
    only_last: bool = True,
):  # sourcery skip: remove-unnecessary-cast
    attachments = L()
    fiscaliza = valida_fiscaliza(login, senha, api, fiscaliza, teste)
    if not isinstance(issue_obj, Issue) and isinstance(issue_obj, (str, int)):
        issue_obj = fiscaliza.issue.get(issue_obj, include=["relations", "attachments"])

    subset = listify(subset)
    issue_type = getattr(getattr(issue_obj, "tracker", None), "name", None)

    if issue_type == "Atividade de Inspeção" and str(getattr(issue_obj, "status", "")).lower() in subset:
        attachments.extend(
            extract_attachment(issue_obj, filename, only_last, fiscaliza)
        )
        return attachments

    if relations := getattr(issue_obj, "relations", []):
        relations = (
            L(relations).map(dict).filter(lambda r: r["issue_to_id"] == issue_obj.id)
        )

        if (
            getattr(getattr(issue_obj, "tracker", None), "name", None)
            == "Solicitação de Inspeção"
        ):
            relations = tqdm(relations, total=len(relations))

        for r in relations:
            issue_obj = fiscaliza.issue.get(
                r["issue_id"], include=["relations", "attachments"]
            )
            issue_type = getattr(getattr(issue_obj, "tracker", None), "name", None)

            if issue_type in {
                "Solicitação de Inspeção",
                "Ação de Inspeção",
            }:
                attachments.extend(
                    extract_attachments(
                        issue_obj,
                        login,
                        senha,
                        api,
                        fiscaliza,
                        teste,
                        subset,
                        filename,
                        only_last,
                    )
                )
            elif (
                issue_type == "Atividade de Inspeção"
                and str(getattr(issue_obj, "status", "")).lower() in subset
            ):
                attachments.extend(extract_attachment(issue_obj, filename, only_last, fiscaliza))
    return attachments